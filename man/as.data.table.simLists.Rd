% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/experiment2.R
\name{as.data.table.simLists}
\alias{as.data.table.simLists}
\title{Coerce elements of a simLists object to a data.table}
\usage{
\method{as.data.table}{simLists}(x, byRep = TRUE, vals,
  objectsFromSim = NULL, objectsFromOutputs = NULL, ...)
}
\arguments{
\item{byRep}{Should the data.table have a column labelled "rep", indicating replicate
number/label. Currently, only \code{TRUE} is accepted.}

\item{vals}{A character vector or list of object names to extract from each
simList, or a list of quoted expressions to calculate for each \code{simList},
or a mix of character and quoted expressions.}

\item{objectsFromSim}{Character vector of objects to extract from the simLists. If
omitted, it will extract all objects from each simList in order to calculate the
\code{vals}. This may have a computational cost.}

\item{objectsFromOutputs}{Character vector of objects to load from the
\code{outputs(sim)} prior to evaluating \code{vals}. If there already is an object
with that same name in the \code{simList}, then it will be overwritten with
the object loaded from \code{outputs(sim)}. If there are many objects with the
same name, specifically from several \code{saveTime} values in the \code{outputs(sim)},
these will all be loaded, one at a time, \code{vals} evaluated one at a time, and
all the unique values will be returned. A column, \code{saveTime}, will be
part of the returned value.}

\item{...}{Currently unused.}
}
\description{
This is particularly useful to build plots using the tidyverse,
e.g., \code{ggplot2}
}
\details{
See examples.
}
\examples{
\dontrun {
# Make 3 simLists -- set up scenarios
endTime <- 5
tmpdir <- file.path(tempdir(), "testing")
tmpCache <- file.path(tempdir(), "testingCache")
# Example of changing parameter values
mySim1 <- simInit(
  times = list(start = 0.0, end = endTime, timeunit = "year"),
  params = list(
    .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
    # Turn off interactive plotting
    fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(10)),
    caribouMovement = list(.plotInitialTime = NA),
    randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
  ),
  modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
  paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
               outputPath = tmpdir,
               cachePath = tmpCache),
  # Save final state of landscape and caribou
  outputs = data.frame(objectName = c(rep("landscape", endTime), "caribou", "caribou"),
                       saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime/2),endTime))),
                       stringsAsFactors = FALSE)
)

mySim2 <- simInit(
  times = list(start = 0.0, end = endTime, timeunit = "year"),
  params = list(
    .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
    # Turn off interactive plotting
    fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(20)),
    caribouMovement = list(.plotInitialTime = NA),
    randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
  ),
  modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
  paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
               outputPath = tmpdir,
               cachePath = tmpCache),
  # Save final state of landscape and caribou
  outputs = data.frame(objectName = c(rep("landscape", endTime), "caribou", "caribou"),
                       saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime/2),endTime))),
                       stringsAsFactors = FALSE)
)

mySim3 <- simInit(
  times = list(start = 0.0, end = endTime, timeunit = "year"),
  params = list(
    .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
    # Turn off interactive plotting
    fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(30)),
    caribouMovement = list(.plotInitialTime = NA),
    randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
  ),
  modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
  paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
               outputPath = tmpdir,
               cachePath = tmpCache),
  # Save final state of landscape and caribou
  outputs = data.frame(objectName = c(rep("landscape", endTime), "caribou", "caribou"),
                       saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime/2),endTime))),
                       stringsAsFactors = FALSE)
)

# Run experiment
sims <- experiment2(sim1 = mySim1, sim2 = mySim2, sim3 = mySim3,
      replicates = 3, useCache = FALSE)

# Convert to data.table so can do stuff with
# Just pull out a variable from the simLists -- simplest case
df1 <- as.data.table(sims, byRep = TRUE, vals = c("nPixelsBurned"))

measure.cols <- grep("nPixelsBurned", names(df1), value = TRUE)
df1Short <- data.table::melt(df1, measure.vars = measure.cols, variable.name = "year")
df1Short[, year := as.numeric(gsub(".*V([[:digit:]])", "\\\\1", df1Short$year))]
library(ggplot2)
p<- ggplot(df1Short, aes(x=year, y=value, group=simList, color=simList)) +
  stat_summary(geom = "point", fun.y = mean) +
  stat_summary(geom = "line", fun.y = mean) +
  stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2)

print(p)

# A quoted function -- do not prefix objects with 'sim' -- next two lines are identical
df1 <- as.data.table(sims, byRep = TRUE, vals = list(NCaribou = quote(length(caribou$x1))))
df1 <- as.data.table(sims, byRep = TRUE, vals = list(NCaribou = "length(caribou$x1)"))

  p<- ggplot(df1, aes(x=simList, y=NCaribou, group=simList, color=simList)) +
    stat_summary(geom = "point", fun.y = mean) +
    stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2)
  print(p)

# A much more complicated object to calculate:
library(raster)
perimToAreaRatioFn <- quote({
  landscape$Fires[landscape$Fires[]==0] <- NA;
  a <- boundaries(landscape$Fires, type = "inner");
  a[landscape$Fires[] > 0 & a[] == 1] <- landscape$Fires[landscape$Fires[] > 0 & a[] == 1];
  peri <- table(a[]);
  area <- table(landscape$Fires[]);
  keep <- match(names(area),names(peri));
  mean(peri[keep]/area)
})

df1 <- as.data.table(sims, byRep = TRUE,
                     vals = c(perimToArea = perimToAreaRatioFn,
                              meanFireSize = quote(mean(table(landscape$Fires[])[-1]))),
                     objectsFromOutputs = c("landscape"))
if (interactive()) {
  # with an unevaluated string
  p <- ggplot(df1, aes(x=saveTime, y=perimToArea, group=simList, color=simList)) +
    stat_summary(geom = "point", fun.y = mean) +
    stat_summary(geom = "line", fun.y = mean) +
    stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2)
  print(p) # may have NAs, giving warning, if perimeter calculation couldn't be completed
}


} # end /dontrun

}
